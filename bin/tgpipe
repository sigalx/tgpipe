#!/bin/bash
set -o nounset
set -o pipefail

CONF="/etc/tgpipe.conf"

usage() {
	cat <<'EOF'
Usage: tgpipe [options] [message]

Options:
  --text                   Send text message (default)
  --md                     Use Markdown parse mode
  --html                   Use HTML parse mode
  --disable-preview        Disable web page previews
  --disable-notification   Telegram silent notification (no sound)
  --verbose                Verbose logging (show curl output)
  --silent                 No output at all (even on errors)
  --file <path>            Send file as document
  --photo <path>           Send image as photo

  --config <path>          Use alternative config file instead of /etc/tgpipe.conf
  --chat <id[,id2,...]>    Override CHAT_ID (can be used multiple times)
  --button-url "Text=URL"  Add inline button with URL
  --button "Text=DATA"     Add inline button with callback_data
  --code                   Send message as preformatted code (HTML <pre><code>)
  --auto-code              Auto-enable --code for long lines
  --tag <tag>              Prefix each line with [tag]
  --help                   Show this help message
EOF
}

# If no arguments and stdin is TTY â†’ show help
if [ $# -eq 0 ] && [ -t 0 ]; then
	usage
	exit 1
fi

MODE="text"
PARSE_MODE=""
DISABLE_PREVIEW="false"
DISABLE_NOTIFICATION="false"
LOG_MODE="normal"
FILE=""

CODE_MODE="false"
AUTO_CODE="false"
TAG=""

declare -a CHAT_OVERRIDE=()
declare -a INLINE_BUTTONS=()
REPLY_MARKUP=""

json_escape() {
	local s=$1
	s=${s//\\/\\\\}
	s=${s//\"/\\\"}
	s=${s//$'\n'/\\n}
	s=${s//$'\r'/\\r}
	echo "$s"
}

html_escape() {
	local s=$1
	s=${s//&/&amp;}
	s=${s//</&lt;}
	s=${s//>/&gt;}
	echo "$s"
}

while [[ "${1-}" == --* ]]; do
	case "$1" in
	--text)
		MODE="text"
		PARSE_MODE=""
		shift
		;;
	--md)
		MODE="text"
		PARSE_MODE="Markdown"
		shift
		;;
	--html)
		MODE="text"
		PARSE_MODE="HTML"
		shift
		;;
	--disable-preview)
		DISABLE_PREVIEW="true"
		shift
		;;
	--disable-notification)
		DISABLE_NOTIFICATION="true"
		shift
		;;
	--verbose)
		LOG_MODE="verbose"
		shift
		;;
	--silent)
		LOG_MODE="silent"
		shift
		;;
	--file)
		if [ -z "${2-}" ]; then
			echo "tgpipe: --file requires a path argument" >&2
			exit 1
		fi
		MODE="file"
		FILE="$2"
		shift 2
		;;
	--photo)
		if [ -z "${2-}" ]; then
			echo "tgpipe: --photo requires a path argument" >&2
			exit 1
		fi
		MODE="photo"
		FILE="$2"
		shift 2
		;;
	--config)
		if [ -z "${2-}" ]; then
			echo "tgpipe: --config requires a path argument" >&2
			exit 1
		fi
		CONF="$2"
		shift 2
		;;
	--chat)
		if [ -z "${2-}" ]; then
			echo "tgpipe: --chat requires an id or comma-separated ids" >&2
			exit 1
		fi
		CHAT_OVERRIDE+=("$2")
		shift 2
		;;
	--button-url)
		if [ -z "${2-}" ]; then
			echo 'tgpipe: --button-url requires "Text=URL"' >&2
			exit 1
		fi
		arg="$2"
		shift 2
		if [ "$arg" = "${arg#*=}" ]; then
			echo 'tgpipe: --button-url argument must be in form "Text=URL"' >&2
			exit 1
		fi
		btn_text=${arg%%=*}
		btn_url=${arg#*=}
		btn_text_esc=$(json_escape "$btn_text")
		btn_url_esc=$(json_escape "$btn_url")
		INLINE_BUTTONS+=("{\"text\":\"$btn_text_esc\",\"url\":\"$btn_url_esc\"}")
		;;
	--button)
		if [ -z "${2-}" ]; then
			echo 'tgpipe: --button requires "Text=DATA"' >&2
			exit 1
		fi
		arg="$2"
		shift 2
		if [ "$arg" = "${arg#*=}" ]; then
			echo 'tgpipe: --button argument must be in form "Text=DATA"' >&2
			exit 1
		fi
		btn_text=${arg%%=*}
		btn_data=${arg#*=}
		btn_text_esc=$(json_escape "$btn_text")
		btn_data_esc=$(json_escape "$btn_data")
		INLINE_BUTTONS+=("{\"text\":\"$btn_text_esc\",\"callback_data\":\"$btn_data_esc\"}")
		;;
	--code)
		CODE_MODE="true"
		shift
		;;
	--auto-code)
		AUTO_CODE="true"
		shift
		;;
	--tag)
		if [ -z "${2-}" ]; then
			echo "tgpipe: --tag requires a value" >&2
			exit 1
		fi
		TAG="$2"
		shift 2
		;;
	--help)
		usage
		exit 0
		;;
	*)
		break
		;;
	esac
done

if [ "${#INLINE_BUTTONS[@]}" -gt 0 ]; then
	joined=$(
		IFS=,
		echo "${INLINE_BUTTONS[*]}"
	)
	REPLY_MARKUP="{\"inline_keyboard\":[[$joined]]}"
fi

if [ -r "$CONF" ]; then
	if perms=$(stat -c '%a' "$CONF" 2>/dev/null); then
		if [ "$perms" != "600" ]; then
			echo "tgpipe: warning: $CONF should be chmod 600 (contains bot token)" >&2
		fi
	fi
	# shellcheck disable=SC1090
	. "$CONF"
fi

if [ -z "${BOT_TOKEN:-}" ] && [ -n "${TGPIPE_BOT_TOKEN:-}" ]; then
	BOT_TOKEN="$TGPIPE_BOT_TOKEN"
fi

if [ -z "${CHAT_ID:-}" ] && [ -n "${TGPIPE_CHAT_ID:-}" ]; then
	CHAT_ID="$TGPIPE_CHAT_ID"
fi

if [ -z "${BOT_TOKEN:-}" ]; then
	echo "tgpipe: BOT_TOKEN not set (check config or env vars)" >&2
	exit 1
fi

if [ "${#CHAT_OVERRIDE[@]}" -eq 0 ] && [ -z "${CHAT_ID:-}" ]; then
	echo "tgpipe: CHAT_ID not set and no --chat provided" >&2
	exit 1
fi

API_URL="https://api.telegram.org/bot${BOT_TOKEN}"

declare -a CHAT_IDS=()
if [ "${#CHAT_OVERRIDE[@]}" -gt 0 ]; then
	for item in "${CHAT_OVERRIDE[@]}"; do
		IFS=',' read -r -a tmp <<<"$item"
		for cid in "${tmp[@]}"; do
			[ -n "$cid" ] && CHAT_IDS+=("$cid")
		done
	done
else
	IFS=',' read -r -a CHAT_IDS <<<"${CHAT_ID}"
fi

MESSAGE="$*"

if ! [ -t 0 ]; then
	MESSAGE="$(cat)"
fi

if [ -z "$MESSAGE" ] && [ -n "${SMARTD_MESSAGE:-}" ]; then
	MESSAGE="$SMARTD_MESSAGE"
fi

if [ -z "$MESSAGE" ]; then
	MESSAGE="(no message text)"
fi

if [ -n "$TAG" ]; then
	MESSAGE="$(printf '%s\n' "$MESSAGE" | awk -v tag="$TAG" '{print "[" tag "] " $0}')"
fi

if [ "$AUTO_CODE" = "true" ] && [ "$CODE_MODE" = "false" ]; then
	threshold="${TGPIPE_AUTO_CODE_THRESHOLD:-120}"
	max_line_len=$(printf '%s\n' "$MESSAGE" | awk '{ if (length > m) m = length } END { print m+0 }')
	if [ "$max_line_len" -gt "$threshold" ] 2>/dev/null; then
		CODE_MODE="true"
	fi
fi

send_curl() {
	local mode="${LOG_MODE:-normal}"
	case "$mode" in silent | verbose | normal) ;; *)
		echo "tgpipe: unknown LOG_MODE='$LOG_MODE', falling back to normal" >&2
		mode="normal"
		;;
	esac

	case "$mode" in
	silent)
		curl -s "$@" >/dev/null 2>&1
		return
		;;
	verbose)
		curl "$@"
		return
		;;
	normal)
		local response http_code body curl_status
		response=$(curl -s -w "\n%{http_code}" "$@")
		curl_status=$?

		if [ $curl_status -ne 0 ]; then
			echo "tgpipe: curl failed with status $curl_status" >&2
			return 1
		fi

		http_code=$(printf '%s\n' "$response" | tail -n1)
		body=$(printf '%s\n' "$response" | sed '$d')

		if [ "$http_code" != "200" ]; then
			echo "tgpipe: HTTP $http_code" >&2
			echo "tgpipe: body: $body" >&2
			return 1
		fi

		if printf '%s\n' "$body" | grep -q '"ok":false'; then
			echo "tgpipe: Telegram API returned ok:false" >&2
			echo "tgpipe: body: $body" >&2
			return 1
		fi

		return 0
		;;
	esac
}

send_text_to_chat() {
	local chat_id="$1"
	local text="$2"
	local max_len="${TGPIPE_MAX_LEN:-4000}"
	local part

	if [ "$max_len" -lt 1 ] 2>/dev/null; then
		max_len=0
	fi

	while [ -n "$text" ]; do
		if [ "$max_len" -eq 0 ] || [ "${#text}" -le "$max_len" ]; then
			part="$text"
			text=""
		else
			local chunk="${text:0:$max_len}"
			local i cut_pos found_nl=0

			for ((i = ${#chunk} - 1; i >= 0; i--)); do
				if [ "${chunk:i:1}" = $'\n' ]; then
					cut_pos=$((i + 1))
					found_nl=1
					break
				fi
			done

			if [ "$found_nl" -eq 1 ]; then
				part="${text:0:$cut_pos}"
				text="${text:$cut_pos}"
			else
				part="$chunk"
				text="${text:$max_len}"
			fi
		fi

		local payload="$part"
		local pmode="$PARSE_MODE"

		if [ "$CODE_MODE" = "true" ]; then
			pmode="HTML"
			payload="<pre><code>$(html_escape "$part")</code></pre>"
		fi

		local args=(
			-X POST "${API_URL}/sendMessage"
			-d chat_id="${chat_id}"
			--data-urlencode text="$payload"
			-d disable_web_page_preview="${DISABLE_PREVIEW}"
			-d disable_notification="${DISABLE_NOTIFICATION}"
		)

		if [ -n "$pmode" ]; then
			args+=(-d parse_mode="${pmode}")
		fi

		if [ -n "$REPLY_MARKUP" ]; then
			args+=(--data-urlencode reply_markup="$REPLY_MARKUP")
		fi

		send_curl "${args[@]}" || return 1
	done
}

send_document_to_chat() {
	local chat_id="$1"
	local caption="$2"
	local file="$3"

	local payload="$caption"
	local pmode="$PARSE_MODE"

	if [ "$CODE_MODE" = "true" ]; then
		pmode="HTML"
		payload="<pre><code>$(html_escape "$caption")</code></pre>"
	fi

	local args=(
		-X POST "${API_URL}/sendDocument"
		-F chat_id="${chat_id}"
		-F caption="$payload"
		-F disable_notification="${DISABLE_NOTIFICATION}"
		-F document="@${file}"
	)

	if [ -n "$pmode" ]; then
		args+=(-F parse_mode="${pmode}")
	fi

	if [ -n "$REPLY_MARKUP" ]; then
		args+=(-F reply_markup="$REPLY_MARKUP")
	fi

	send_curl "${args[@]}"
}

send_photo_to_chat() {
	local chat_id="$1"
	local caption="$2"
	local file="$3"

	local payload="$caption"
	local pmode="$PARSE_MODE"

	if [ "$CODE_MODE" = "true" ]; then
		pmode="HTML"
		payload="<pre><code>$(html_escape "$caption")</code></pre>"
	fi

	local args=(
		-X POST "${API_URL}/sendPhoto"
		-F chat_id="${chat_id}"
		-F caption="$payload"
		-F disable_notification="${DISABLE_NOTIFICATION}"
		-F photo="@${file}"
	)

	if [ -n "$pmode" ]; then
		args+=(-F parse_mode="${pmode}")
	fi

	if [ -n "$REPLY_MARKUP" ]; then
		args+=(-F reply_markup="$REPLY_MARKUP")
	fi

	send_curl "${args[@]}"
}

case "$MODE" in
text)
	for cid in "${CHAT_IDS[@]}"; do
		send_text_to_chat "$cid" "$MESSAGE" || exit 1
	done
	;;
file)
	if [ ! -r "$FILE" ]; then
		echo "tgpipe: file not found or unreadable: $FILE" >&2
		exit 1
	fi
	for cid in "${CHAT_IDS[@]}"; do
		send_document_to_chat "$cid" "$MESSAGE" "$FILE" || exit 1
	done
	;;
photo)
	if [ ! -r "$FILE" ]; then
		echo "tgpipe: photo not found or unreadable: $FILE" >&2
		exit 1
	fi
	for cid in "${CHAT_IDS[@]}"; do
		send_photo_to_chat "$cid" "$MESSAGE" || exit 1
	done
	;;
esac
